// Code generated by optiongen. DO NOT EDIT.
// optiongen: github.com/timestee/optiongen

package config

import (
	"sync/atomic"
	"unsafe"
)

// ETCD should use NewETCD to initialize it
type ETCD struct {
	Endpoints       []string  `xconf:"endpoints"`
	TimeoutsPointer *Timeouts `xconf:"timeouts_pointer"`
}

// ApplyOption apply mutiple new option and return the old ones
// sample:
// old := cc.ApplyOption(WithTimeout(time.Second))
// defer cc.ApplyOption(old...)
func (cc *ETCD) ApplyOption(opts ...ETCDOption) []ETCDOption {
	var previous []ETCDOption
	for _, opt := range opts {
		previous = append(previous, opt(cc))
	}
	return previous
}

// ETCDOption option func
type ETCDOption func(cc *ETCD) ETCDOption

// WithETCDEndpoints option func for Endpoints
func WithETCDEndpoints(v ...string) ETCDOption {
	return func(cc *ETCD) ETCDOption {
		previous := cc.Endpoints
		cc.Endpoints = v
		return WithETCDEndpoints(previous...)
	}
}

// WithETCDTimeoutsPointer option func for TimeoutsPointer
func WithETCDTimeoutsPointer(v *Timeouts) ETCDOption {
	return func(cc *ETCD) ETCDOption {
		previous := cc.TimeoutsPointer
		cc.TimeoutsPointer = v
		return WithETCDTimeoutsPointer(previous)
	}
}

// NewETCD new ETCD
func NewETCD(opts ...ETCDOption) *ETCD {
	cc := newDefaultETCD()
	for _, opt := range opts {
		opt(cc)
	}
	if watchDogETCD != nil {
		watchDogETCD(cc)
	}
	return cc
}

// InstallETCDWatchDog the installed func will called when NewETCD  called
func InstallETCDWatchDog(dog func(cc *ETCD)) { watchDogETCD = dog }

// watchDogETCD global watch dog
var watchDogETCD func(cc *ETCD)

// newDefaultETCD new default ETCD
func newDefaultETCD() *ETCD {
	cc := &ETCD{}

	for _, opt := range [...]ETCDOption{
		WithETCDEndpoints([]string{"10.0.0.1", "10.0.0.2"}...),
		WithETCDTimeoutsPointer(&Timeouts{}),
	} {
		opt(cc)
	}

	return cc
}

// AtomicSetFunc used for XConf
func (cc *ETCD) AtomicSetFunc() func(interface{}) { return AtomicETCDSet }

// atomicETCD global *ETCD holder
var atomicETCD unsafe.Pointer

// onAtomicETCDSet global call back when  AtomicETCDSet called by XConf.
// use ETCDInterface.ApplyOption to modify the updated cc
// if passed in cc not valid, then return false, cc will not set to atomicETCD
var onAtomicETCDSet func(cc ETCDInterface) bool

// InstallCallbackOnAtomicETCDSet install callback
func InstallCallbackOnAtomicETCDSet(callback func(cc ETCDInterface) bool) { onAtomicETCDSet = callback }

// AtomicETCDSet atomic setter for *ETCD
func AtomicETCDSet(update interface{}) {
	cc := update.(*ETCD)
	if onAtomicETCDSet != nil && !onAtomicETCDSet(cc) {
		return
	}
	atomic.StorePointer(&atomicETCD, (unsafe.Pointer)(cc))
}

// AtomicETCD return atomic *ETCDVisitor
func AtomicETCD() ETCDVisitor {
	current := (*ETCD)(atomic.LoadPointer(&atomicETCD))
	if current == nil {
		defaultOne := newDefaultETCD()
		if watchDogETCD != nil {
			watchDogETCD(defaultOne)
		}
		atomic.CompareAndSwapPointer(&atomicETCD, nil, (unsafe.Pointer)(defaultOne))
		return (*ETCD)(atomic.LoadPointer(&atomicETCD))
	}
	return current
}

// all getter func
func (cc *ETCD) GetEndpoints() []string        { return cc.Endpoints }
func (cc *ETCD) GetTimeoutsPointer() *Timeouts { return cc.TimeoutsPointer }

// ETCDVisitor visitor interface for ETCD
type ETCDVisitor interface {
	GetEndpoints() []string
	GetTimeoutsPointer() *Timeouts
}

// ETCDInterface visitor + ApplyOption interface for ETCD
type ETCDInterface interface {
	ETCDVisitor
	ApplyOption(...ETCDOption) []ETCDOption
}
