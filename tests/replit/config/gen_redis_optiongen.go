// Code generated by optiongen. DO NOT EDIT.
// optiongen: github.com/timestee/optiongen

package config

import (
	"sync/atomic"
	"unsafe"
)

// Redis struct
type Redis struct {
	Endpoints      []string `xconf:"endpoints"`
	Cluster        bool     `xconf:"cluster"`
	TimeoutsStruct Timeouts `xconf:"timeouts_struct"`
}

// SetOption apply single option
func (cc *Redis) SetOption(opt RedisOption) {
	_ = opt(cc)
}

// ApplyOption apply mutiple options
func (cc *Redis) ApplyOption(opts ...RedisOption) {
	for _, opt := range opts {
		_ = opt(cc)
	}
}

// GetSetOption apply new option and return the old optuon
// sample:
// old := cc.GetSetOption(WithTimeout(time.Second))
// defer cc.SetOption(old)
func (cc *Redis) GetSetOption(opt RedisOption) RedisOption {
	return opt(cc)
}

// RedisOption option func
type RedisOption func(cc *Redis) RedisOption

// WithRedisEndpoints option func for Endpoints
func WithRedisEndpoints(v ...string) RedisOption {
	return func(cc *Redis) RedisOption {
		previous := cc.Endpoints
		cc.Endpoints = v
		return WithRedisEndpoints(previous...)
	}
}

// WithRedisCluster option func for Cluster
func WithRedisCluster(v bool) RedisOption {
	return func(cc *Redis) RedisOption {
		previous := cc.Cluster
		cc.Cluster = v
		return WithRedisCluster(previous)
	}
}

// WithRedisTimeoutsStruct option func for TimeoutsStruct
func WithRedisTimeoutsStruct(v Timeouts) RedisOption {
	return func(cc *Redis) RedisOption {
		previous := cc.TimeoutsStruct
		cc.TimeoutsStruct = v
		return WithRedisTimeoutsStruct(previous)
	}
}

// NewRedis(opts... RedisOption) new Redis
func NewRedis(opts ...RedisOption) *Redis {
	cc := newDefaultRedis()

	for _, opt := range opts {
		_ = opt(cc)
	}
	if watchDogRedis != nil {
		watchDogRedis(cc)
	}
	return cc
}

// InstallRedisWatchDog the installed func will called when NewRedis(opts... RedisOption)  called
func InstallRedisWatchDog(dog func(cc *Redis)) {
	watchDogRedis = dog
}

// watchDogRedis global watch dog
var watchDogRedis func(cc *Redis)

// newDefaultRedis new default Redis
func newDefaultRedis() *Redis {
	cc := &Redis{}

	for _, opt := range [...]RedisOption{
		WithRedisEndpoints([]string{"192.168.0.1", "192.168.0.2"}...),
		WithRedisCluster(true),
		WithRedisTimeoutsStruct(Timeouts{}),
	} {
		_ = opt(cc)
	}

	return cc
}

// AtomicSetFunc used for XConf
func (cc *Redis) AtomicSetFunc() func(interface{}) { return AtomicRedisSet }

// atomicRedis global *Redis holder
var atomicRedis unsafe.Pointer

// AtomicRedisSet atomic setter for *Redis
func AtomicRedisSet(update interface{}) {
	atomic.StorePointer(&atomicRedis, (unsafe.Pointer)(update.(*Redis)))
}

// AtomicRedis return atomic *Redis visitor
func AtomicRedis() RedisVisitor {
	current := (*Redis)(atomic.LoadPointer(&atomicRedis))
	if current == nil {
		atomic.CompareAndSwapPointer(&atomicRedis, nil, (unsafe.Pointer)(newDefaultRedis()))
		return (*Redis)(atomic.LoadPointer(&atomicRedis))
	}
	return current
}

// all getter func
// GetEndpoints return struct field: Endpoints
func (cc *Redis) GetEndpoints() []string { return cc.Endpoints }

// GetCluster return struct field: Cluster
func (cc *Redis) GetCluster() bool { return cc.Cluster }

// GetTimeoutsStruct return struct field: TimeoutsStruct
func (cc *Redis) GetTimeoutsStruct() Timeouts { return cc.TimeoutsStruct }

// RedisVisitor visitor interface for Redis
type RedisVisitor interface {
	GetEndpoints() []string
	GetCluster() bool
	GetTimeoutsStruct() Timeouts
}
