// Code generated by optiongen. DO NOT EDIT.
// optiongen: github.com/timestee/optiongen

package xcmdtest

// Log should use NewLog to initialize it
type Log struct {
	LogLevel int
}

// NewLog new Log
func NewLog(opts ...LogOption) *Log {
	cc := newDefaultLog()
	for _, opt := range opts {
		opt(cc)
	}
	if watchDogLog != nil {
		watchDogLog(cc)
	}
	return cc
}

// ApplyOption apply mutiple new option and return the old ones
// sample:
// old := cc.ApplyOption(WithTimeout(time.Second))
// defer cc.ApplyOption(old...)
func (cc *Log) ApplyOption(opts ...LogOption) []LogOption {
	var previous []LogOption
	for _, opt := range opts {
		previous = append(previous, opt(cc))
	}
	return previous
}

// LogOption option func
type LogOption func(cc *Log) LogOption

// WithLogLevel option func for filed LogLevel
func WithLogLevel(v int) LogOption {
	return func(cc *Log) LogOption {
		previous := cc.LogLevel
		cc.LogLevel = v
		return WithLogLevel(previous)
	}
}

// InstallLogWatchDog the installed func will called when NewLog  called
func InstallLogWatchDog(dog func(cc *Log)) { watchDogLog = dog }

// watchDogLog global watch dog
var watchDogLog func(cc *Log)

// newDefaultLog new default Log
func newDefaultLog() *Log {
	cc := &Log{}

	for _, opt := range [...]LogOption{
		WithLogLevel(1),
	} {
		opt(cc)
	}

	return cc
}

// all getter func
func (cc *Log) GetLogLevel() int { return cc.LogLevel }

// LogVisitor visitor interface for Log
type LogVisitor interface {
	GetLogLevel() int
}

// LogInterface visitor + ApplyOption interface for Log
type LogInterface interface {
	LogVisitor
	ApplyOption(...LogOption) []LogOption
}
